\documentclass[10pt]{article}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{float}
\graphicspath{ {images/} }
\begin{document}

\begin{center}
\textbf{Setting up the Raspberry Pi based field sensor monitor}

August 2016
\end{center}
\newpage

\tableofcontents
\newpage

\section{INTRODUCTION}
This document describes how to set up and use the field monitoring system based on a Raspberry Pi base station and Moteino/Arduino based loggers. It provides a 
description of the hardware used and how to set up specific parameters in software, such as logging frequency.

In this document, the term ``controller'' refers to the Moteino which is attached to the Raspberry Pi. It receives data from ``loggers'', which are the independent
Moteinos with photodiodes (and/or other sensors) attached. The Raspberry Pi takes pictures and is turned off and off by the controller. The term ``base station'' refers to the combination of Raspberry Pi and Controller, because they work together.

The network operates on a star topology, with individual battery powered loggers reporting back to a base station. Loggers read from their photodiode arrays only when
they are told to by the controller. The controller tells the loggers when to read from their sensors, and also turns the Raspberry Pi on and off. Turning the Pi off when
it's not needed results in a dramatic power saving. Like the loggers, the controller is a Moteino microcontroller with a radio attached. It's necessary to set up radio
parameters so that the right loggers are talking to the right controller. These parameters are set out and explained in this document.

The Raspberry Pi acts as a data logger and camera operator. At each logging interval (which must be a multiple of 5 minutes) it is woken by the controller. The controller
sends any data received from the loggers to the Raspberry Pi. Once this data has been received, the Pi captures and saves an image before automatically shutting down. If an ethernet cable is connected, it won't shut itself down, but power will be cut by the controller after about ten seconds. To work around this, the Pi needs to be powered seperately when retrieving data. This process is also set out in this document.

\subsection{On Your Computer}

\subsubsection{Development Environment}
For uploading code to the controller and loggers, you can use the Arduino IDE (Integrated Development Environment). This is a cross platform IDE (you can download it for
Windows as well as Mac and Linux) which can be found at \url{https://www.arduino.cc/en/Main/Software}. There is a good overview of how to use the Arduino IDE at
\url{https://www.arduino.cc/en/Guide/Environment}. 

When you have Arduino installed, there are a couple of things you need to do before you can upload code. There are some extra bits of code, called libraries, that the
field logging system uses. You can download these, but they are included with the files for this project in \textit{field\_monitor/arduino\_libraries}. These need to
go in a specific place for the Arduino IDE to find them. For windows, you should have a directory called \textit{My Documents/Arduino/libraries}. Place all of the folders
inside \textit{field\_monitor/arduino\_libraries} into this directory. For Linux, they need to go in \textit{~/sketchbook/libraries}. 

You need to restart the Arduino IDE for it to find the libraries.

You also need to make sure you have the right board selected. The Moteino is very similar to the Arduino Uno, so we can use that as our upload target:

\begin{itemize}
 \item Open the Arduino IDE program
 \item Go to \textit{Tools} - \textit{Board}
 \item Select \textit{Arduino Uno} from the list
\end{itemize}

You also need to select the right port:

\begin{itemize}
 \item Open the Arduino IDE 
 \item Go to \textit{Tools} - \textit{Port}
 \item Select the port that your Moteino is on. If you're not sure, unplug the Moteino, and see which one disappears
 \item If you get a ``Not in sync'' error when uploading, you're probably connected to the wrong port
\end{itemize}

Once these are set up, you can use \textit{File - Open} to open the sketch you want to edit (in this case, \textit{field\_monitor/controller.ino} or \textit{field\_monitor/logger.ino}. The big tick at the top of the screen is used to \textbf{compile} to code; it should compile without errors. The arrow is used to upload the code to the target board. 

When you upload to the Moteino, its onboard LED will flash a few times when uploading, then stop. If it carries on flashing, check out the error codes in section 2.2 to find out why.

\subsection{Additional hardware}
You will need an SD card reader and a computer that either has an SD card port or a USB adapter (Google ``usb sd card adapter''). This will work fine for Linux, but not on Windows systems, because the Pi has a Linux filesystem type. If you're using Windows, you'll need to find a program that allows you to view \textit{ext4} filesystems.

To connect the Moteino to your computer so that you can program it, you will need an FTDI cable like this one
\url{http://uk.rs-online.com/web/p/interface-development-kits/0429307/}. The cable \textbf{must} have 5V power and 3.3V logic. The Moteino is designed to run at 3.3V,
so 5V logic is too high (the power input can be 5V, because this goes through a regulator which lowers it to 3.3V). This connects to the 6-pin header on the Moteino. Make
sure that when you plug it in, the black wire (ground) on the cable connects to the \textit{GND} pin of the header. \newline

\textbf{Before plugging in the Moteino, it's a good idea to turn off power from any other sources. You'll probably get away with not doing this, but it's good practice}. 
Have a look at the 6-pin header on the Moteino. You can see that at one end, a pin is labelled \textbf{GND}, and at the other, a pin is labelled \textbf{DTR}. Line up the FTDI header so that the black wire is lined up with \textbf{GND}, and the green wire is lined up with \textbf{DTR}, and plug it in. Depending on what code the Moteino is already running, the LED might blink.

\section{SETUP}

\subsection{Raspberry Pi}
The SD card image provided has everything already set up, but there are some more details here if you need to change anything. If you just want to set up a new Pi with the
provided image, go to \textbf{Setting up the Pi: The Easy Way}.

The Raspberry Pi is set up so that it automatically runs a script when it starts. This script listens for any input from the controller and then captures and saves an image using the camera. Then it shuts down the pi. This script is located in \textit{/home/pi/scripts} and it runs from \textit{/etc/rc.local}. Scripts run from \textit{rc.local} run as the ``root'' user (similar to Administrators in Windows). You can look at this file by typing \textit{cat /etc/rc.local}. The Raspberry Pi is turned off and off by the controller; it turns the Pi on, waits for it to complete its tasks, then turns it off. If the Pi detects an Ethernet connection, it won't shut down after running its script.

\subsubsection{Setting up a new Pi: The Easy Way}
All you need to set up a Raspberry Pi this way is the Pi itself, an SD card (preferably class 10, 8GB or greater) and card reader, the camera module, and an Ethernet cable. \textbf{This part of the setup assumes that the Pi is not connected to the controller and is being powered through the micro USB port as normal}.

There is a file called \textit{pi\_logger.img.zip} included in \textit{field\_monitor/raspberry\_pi}. This is an image file, and it's basically an ``image'' of a working Pi running our code and with our settings. If we flash this image to a new SD card, it will have everything we need for the Pi to work with no setup. It's compressed, so you need to unzip it first - this should result in a file called \textit{pi\_logger.img}.

In Linux, use the \textit{dd} tool to flash the new SD card, with the command
\begin{verbatim}
dd if=field_monitor/raspberry_pi/pi_logger.iso of=/path/to/new/sdcard
\end{verbatim}

In Windows, follow the instruction from the Raspberry Pi Foundation at \url{https://www.raspberrypi.org/documentation/installation/installing-images/windows.md}. It's
not as hard as it looks! You just need to install a program called Win32DiskImager, which will allow you to write to the SD card.

If you use an SD card with a capacity greater than 8GB, you will still only have 8GB of storage unless you expand the partition so that the Pi can
access the extra room. You also need to check that the camera module is enabled. To do this, you will need to access the Pi over Ethernet. The image file is already set up to allow you to do this, but you will need to do some setting up on your own computer as well. This process will also be useful later on for downloading data.

The Raspberry Pi image you just flashed is set up with a certain IP address. IP addresses are how computers identify each other over network connections. You're computer needs to have an IP address which has the same subnet as the Raspberry Pi. IPv4 IP addresses are usually of the format \textit{192.168.1.1}. A subnet mask of \textit{255.255.255.0} means that the first three numbers need to match for the computers to talk to each other. The Pi by default has an IP address of \textbf{178.122.1.200}. So your IP address needs to be the same except for the last number (e.g. 178.122.1.50). The instructions below tell you how to set this up. \newline

\textbf{For Linux (Ubuntu 14.04)}:

\begin{itemize}
 \item Click on the network icon in the menu bar
 \item Go to \textit{Edit Connections}
 \item Click on \textit{Add}
 \item Select the \textit{Ethernet} option
 \item Give the connection a useful name, like ``Pi connect''
 \item Go to \textit{IPv4 settings}
 \item Change the \textit{Method} to \textit{Manual}
 \item Add an address - \textit{Address:} 178.122.1.50, \textit{Netmask:} 255.255.255.0, \textit{Gateway:} 178.122.1.1
 \item Connect your computer and the Pi with an Ethernet cable, then turn on the Pi
 \item Your computer should detect the wired connection and connect 
\end{itemize}

You should now be able to log into the Pi by using:
\begin{verbatim}
 ssh pi@178.122.200
\end{verbatim}

The password is \textit{gogerddan}. \newline

\textbf{For Windows 7}:

\begin{itemize}
 \item In \textit{field\_monitor/windows\_utils}, there is a file called \textit{putty.exe}. Copy this to your computer and double click to run it. It will install a program called \textit{Putty}
 \item Plug one end of the Ethernet cable into your computer, and the other end into the Pi
 \item Turn on the Pi
 \item On Windows, go to \textit{Control Panel} - \textit{Network and Internet} - \textit{Network and Sharing Center}
 \item The connection to the Pi should show up as an ``Unidentified Network'' - usually there is a picture of a park bench
 \item Click on \textit{Local Area Connection} on the right hand side
 \item A new window should appear with some details. Click on \textit{Properties}
 \item In the list, select \textit{Internet Protocol Version 4 (TCP/IPv4)}
 \item With that selected, click \textit{Properties}
 \item A new window will open. Select the \textit{Use the following IP address} option
 \item Type in these settings - \textit{IP Address:} 178.122.1.50, \textit{Subnet:} 255.255.255.0, \textit{Gateway:} 178.122.1.1
 \item Leave the DNS server section blank
 \item Save and exit
\end{itemize}

Now you can use Putty to connect to the Pi:

\begin{itemize}
 \item Start Putty
 \item In \textit{Host Name (or IP address):} type \textit{pi@178.122.1.200}
 \item The \textit{Port} should be \textit{22}
 \item Click \textit{Open}. If a warning box comes up, click \textit{Yes}
 \item A black terminal will come up - when prompted, enter the password (\textit{gogerddan})
 \item You are now logged in to the Pi
\end{itemize}

\textbf{Note: On Windows computers, doing this might stop your computer from connecting properly to other wired connections. If this happens, you will need to reset the settings to \textit{Obtain an IP address automatically} every time you use a different wired network. You can use something like NetSetMan (\url{http://www.netsetman.com/en/freeware}) to manage your connections.} \newline

Now that you are logged in to the Pi, type 
\begin{verbatim}
sudo raspi-config
\end{verbatim}

Select the second option in the dialog box, labelled \textit{Expand root partition to fill SD card}. This will expand the available space to fill the SD card. From the same menu, you can also make sure that the camera module is enabled by selecting \textit{Camera}. Then select \textit{Finish} (you don't need to reboot - the next step will just turn off the Pi).

To turn off the Pi (try not to ever just switch off the power - it can corrupt the SD card), you can type
\begin{verbatim}
 sudo halt
\end{verbatim}

This will shut down the Pi. After about ten seconds, the Pi will be off, though the red LED will still be on. At this point it is safe to turn off power to the Pi.
 
Once you have the SD card flashed and expanded, install it in the Raspberry Pi, and connect the camera. There are instructions on how to connect the camera at
\url{https://www.raspberrypi.org/documentation/usage/camera/} (just the physical ``Connecting the Camera'' part - the rest is already set up on the SD card). The software on the Pi is now ready to go. 

\subsubsection{Setting up a new Pi: The Harder Way}
If you're familiar with Linux, the command line and SSH, you can set everything up from scratch. We will set up the Pi to connect via Ethernet to your machine, so you don't even need an internet connection (this is also useful for downloading data from the Pi when it's in the field - see later section). This section assumes that you already have a Pi running Raspbian (Jessie or later) which you want to set up for use with this system, and that you have root access. 

The first thing to do is to set up the Ethernet connection so that your machine can communicate directly to the Pi. If your Pi is already connected to the internet, this
isn't really necessary, but it does provide another avenue of data collection when the Pi is located remotely. To connect to the Pi this way, your machine and the Pi 
need to be within the same subnet. The easiest way to do this is to set up static IP adresses on the Pi and on your machine.

To set a static IP on the Pi , you need to mount the SD card in your machine and edit \textit{/etc/dhcpcd.conf}. Insert the following at the bottom of the file (you can 
replace the IP address with whatever you prefer, but this document assumes these settings):

\begin{verbatim}
interface eth0

static ip_address=178.122.1.200/24
static routers=178.122.1.1
static domain_name_servers=178.122.1.1
\end{verbatim}

Now you need to set up a new ethernet connection on your machine with an IP address within the same subnet as the Raspberry Pi, and log in to the Pi using SSH. For this, you can follow the instruction in section 2.1.1 above.

Once you are logged in, check that the camera is enabled. Type:

\begin{verbatim}
 sudo raspi-config
\end{verbatim}

Select the ``camera'' option. Select ``finish'' to set the option and reboot. It's also a good idea to change from the default password if you haven't already - 
use the \textit{passwd} command. 

Next, we need to set up the required Python packages. If you have an internet connection, you can just install these via \textit{apt-get} - the following applies if 
you only have a direct connection to the Pi, via SD card or Ethernet.

There are seven packages located in \textit{field\_monitor/raspberry\_pi/packages}. To get them onto the Pi, you can just mount the SD card
and copy them into a suitable directory to install from (such as ~), or you can copy them over the Ethernet connection using Secure Copy (SCP). To use SCP, the 
command is:

\begin{verbatim}
scp path/to/file/being/copied pi@178.122.1.200:/home/pi
\end{verbatim}

The packages need to be installed in the right order, as some depend on others. The command to install the \textit{.deb} packages is:

\begin{verbatim}
 sudo dpkg -i <package name>
\end{verbatim}

For the others, navigate into the package directory, e.g.:

\begin{verbatim}
 cd netifaces-0.10.4
\end{verbatim}

Then install using Python:

\begin{verbatim}
 sudo python setup.py install
\end{verbatim}

The installation order is:

\begin{itemize}
 \item libpython2.7-dev
 \item libpython-dev 
 \item python2.7-dev 
 \item python-dev 
 \item netifaces
 \item picamera
 \item piserial
\end{itemize}

Once all of the packages are installed, you need to upload a Python script to the Raspberry Pi. The script is located at
\textit{field\_monitor/raspberry\_pi/process\_data.py} and controls everything relevant to the Pi's field monitoring. As with the packages, you can upload this by
mounting the SD card or by using SCP. It's recommended to place it in a directory called \textit{/home/pi/scripts}. The script will create the directories it needs to store the data, so don't worry about that unless you are setting up a custom directory structure. If you're using custom directories, make sure you change all of the paths in \textit{process\_data.py} so that your data gets stored properly.

The \textit{process\_data.py} script needs execute permissions, so make sure to run:

\begin{verbatim}
 chmod +x process_data.py
\end{verbatim}

We need the Python script to run at boot, so that when the controller turns on the Pi, the Pi automatically picks up data from the controller, captures an
image, and shuts itself down. We can do this by running \textit{process\_data.py} from \textit{/etc/rc.local}. Add the following line to \textit{/etc/rc.local} before
\textit{exit 0} (remember to change the file path, if it's not in \textit{/home/pi/scripts}):

\begin{verbatim}
 python /home/pi/scripts/process_data.py &
\end{verbatim}

Next there are a couple of things we need to do to allow the Pi to communicate with the controller over serial GPIO. First, edit \textit{/boot/cmdline.txt} and remove
the following:

\begin{verbatim}
 console=ttyAMA0,115200 kgdboc=ttyAMA0,115200
\end{verbatim}

This will prevent the Pi from sending data over serial when it's booting. Next, we need to disable the console on the serial port. While logged in to the Raspberry Pi,
type:

\begin{verbatim}
 sudo systemctl disable serial-getty@ttyAMA0.service
\end{verbatim}

Finally, even though we have disabled serial output at boot, there is still a line that prints when the kernel is being uncompressed. To get rid of this, we can 
get Raspbian to boot from an uncompressed image. This is a little tricky, and you can find the original instructions here 
\url{http://raspberrypi.stackexchange.com/questions/24583/ttyama0-disabled-but-still-shows-one-boot-message}. Otherwise, you can follow these instructions:

\begin{itemize}
 \item SSH into the Pi
 \item Type the following command (\textbf{Note:} If you're using an older Raspberry Pi (less than Model 2), replace \textit{kernel7} with \textit{kernel}):
	\begin{verbatim}
	 od -A d -t x1 /boot/kernel7.img | grep '1f 8b 08 00'
	\end{verbatim}
  \item You should see a line that looks like this (example 1):
	\begin{verbatim}
	 0017360 1f 8b 08 00 00 00 00 00 02 03 e4 fd 0b 7c 54 d5
	\end{verbatim}
	Or like this (example 2). Notice the extra \textbf{08} at the end:
	\begin{verbatim}
	 0017360 00 00 00 00 00 00 00 00 1f 8b 08 00 00 00 00 00
	\end{verbatim}
  \item If your output looks like example 1, the \textbf{offset} is 17360
  \item If your output looks like example 2, the \textbf{offset} is 17360 + 08, or 17368
  \item Type:
	\begin{verbatim}
	 sudo -i
	\end{verbatim}
	To get an interactive root shell
  \item Type the following command to create an uncompressed copy of the kernel, replacing the word \textit{OFFSET} with the \textbf{offset} number
	you found above:
	\begin{verbatim}
	 dd if=/boot/kernel.img skip=1 bs=OFFSET | gzip -d >/boot/kernel_uncompressed.img
	\end{verbatim}
  \item Now run the following commands to back up the current compressed kernel, and replace it with the uncompressed version:
	\begin{verbatim}
	 cd /boot
	 cp kernel.img kernel_compressed.img
	 cp kernel_uncompressed.img kernel.img
	 reboot
	\end{verbatim}
  \item If your Pi boots successfully, it has worked
\end{itemize}

That's it! Your Pi should now be able to run everything it needs for the field monitor.

\subsubsection{Images and space}
The Raspberry Pi will capture images with a default resolution of 1080x720. These images are about 500kB in size. A 16GB SD card will have about 11GB of free space, so you have room for 20,000 images. If you're capturing an image every half an hour, that gives you enough space to save images for several years. If you're capturing an image every five minutes, you only have enough room for a couple of months. Bear in mind that you might need to delete images fairly frequently to make room if you're using a higher logging frequency (see section 3.4).

You can change the resolution of the images in the \textit{process\_data.py} script (line 85).

\subsection{Logger}
The logger is the Moteino with the light sensor array attached. It runs from 4 x AA batteries and has a low power radio to send data back to the controller. The controller
that the logger is sending data back to must have the same \textit{NETWORK\_ID} as the logger, or they can't communicate.

When setting up a new logger, there are a few things that you need to change, and a few things that you can change if you want to. As a minimum, you need to:

\begin{itemize}
 \item Check that the logger is on the right network, so that it can communicate with the right controller
 \item Check that the logger has the right \textit{CONTROLLER\_ID} - this is the \textit{LOGGER\_ID} of the controller it's sending data back to
 \item Check that the logger's \textit{LOGGER\_ID} is unique on it's network
\end{itemize}

When you apply power to the logger, you shouldn't see any activity on the LED. If the LED flashes, you have problem. The logger automatically checks some of its parameters to make sure that they aren't outside the limits. You will see several flashes in quick succession, followed by a two second gap. The number of flashes you see indicates the problem:

\begin{itemize}
 \item \textbf{Two flashes}	- the number of photodiodes is too high (more than 8) or too low (less than 0)
 \item \textbf{Three flashes}	- the network ID is too high (more than 253) or too low (less than 0)
 \item \textbf{Four flashes}	- the logger ID is too high (more than 253) or too low (less than 2)
 \item \textbf{Five flashes}	- the maximum number of photodiodes has been changed, and does not equal 8
\end{itemize}
   
\subsubsection{Radio parameters}

\paragraph{LOGGER\_ID}
The \textit{LOGGER\_ID} is the unique number of the logger. All loggers with the same \textit{NETWORK\_ID} need to have different \textit{LOGGER\_ID}'s. This is partly so 
that when you look at the resulting data, you will know what logger it came from. It also allows the radios to identify each other, and to prevent clashes between 
loggers. 

The logger ID is transmitted to the controller along with the data from the logger. Because there is a limit to how much data can be transmitted at once, there is a limit
to how big the \textit{LOGGER\_ID} can be, because it is only allowed to take up one byte, or eight bits. The highest number you can represent with eight bits is 255. So,
including zero, we can have up to 256 unique \textit{LOGGER\_ID}'s on one network (networks work the same way). One of these numbers (the number 1) is actually taken by
the controller, and the number 255 is used as a ``broadcast'', meaning that all loggers on the network can see data transmitted to 255.

So, when you are setting up a new logger, set the logger ID to something greater than 1 and less than 255, and make sure that no other loggers with the same 
\textit{NETWORK\_ID} have the same \textit{LOGGER\_ID}. 

\paragraph{NETWORK\_ID}
The \textit{NETWORK\_ID} is used to identify which loggers are on the same network, i.e. which loggers can talk to each other. If you have a Raspberry Pi set up in one
field, with a controller with a \textit{NETWORK\_ID} of 100, all of the loggers that need to talk to that controller must also have a \textit{NETWORK\_ID} of 100. If you 
set up another base station in a different field nearby, you probably don't want the loggers in the first field to also be transmitting to that controller.

So, each controller has a unique \textit{NETWORK\_ID}. Like \textit{LOGGER\_ID}'s, \textit{NETWORK\_ID}'s are limited. So the \textit{NETWORK\_ID} needs to be between 1 and 254, and all loggers that send data to that controller have the same \textit{NETWORK\_ID} as it.

\paragraph{CONTROLLER\_ID}
The \textit{CONTROLLER\_ID} is used to identify the controller, which acts as a ``gateway'' to the Raspberry Pi. So, it's the \textit{LOGGER\_ID} of the controller. Make
sure that you put the right textit{CONTROLLER\_ID} for the controller that the logger is sending to.

\paragraph{FREQUENCY}
This is just the frequency of the radio chip - 433MHz is within the ISM (Industry, Scientific and Medical) frequency band, which means it is a legal frequency for low power radio communications.

\paragraph{ENCRYPTKEY}
This is an encryption key - only loggers with the same key can undertsand each other's transmissions. For this reason, like the \textit{NETWORK\_ID}, all loggers that
talk to each other (including the controller) must have the same \textit{ENCRYPTKEY}. It \textbf{must} be 16 characters long. This encryption also means that no one
else can pick up packets being sent on your network.

\subsubsection{Logging parameters}

\paragraph{NUM\_PHOTODIODES}
This is the number of photodiodes attached to the logger. They will be read from in order, from analog pin 0 to \textit{NUM\_PHOTODIODES}-1. Moteinos only have eight analog pins (A0 to A7), so this number should never be greater than 8, but it can be less, for example, if you need to use an analog pin for a different sensor. If you don't use all of them for the photodiodes, then always pick the highest number analog pin for the other sensor. So, if you want to use a temperature sensor, put it on A7, and then change \textit{NUM\_PHOTODIODES} to 7.

\subsection{Controller}
The controller is the Moteino attached to the Raspberry Pi. Most of the parameters for the controller are the same as for the logger. The controller's \textit{LOGGER\_ID} is the logger's \textit{CONTROLLER\_ID}. 

Like the logger, the controller will flash to indicate any problems:

\begin{itemize}
 \item \textbf{Three flashes}	- the network ID is too high (more than 253) or too low (less than 0)
 \item \textbf{Four flashes}	- the logger ID is too high (more than 253) or too low (less than 2)
 \item \textbf{Five flashes}	- the maximum number of photodiodes has been changed, and does not equal 8
 \item \textbf{Six flashes}	- the logging frequency isn't 5, 10, 20, 30 or 0
\end{itemize}

\subsubsection{Logging parameters}

\paragraph{READ\_FREQ}
This is the frequency at which readings should be taken. The logger has no real concept of time - it just wakes up every five minutes to check for any radio packets sent by the controller. So, the logging frequency is only set on the controller. \textit{READ\_FREQ} can be 5 (for every five minutes), 10 (for every ten minutes), 20 (for every twenty minutes), 30 (for every half and hour) or 0 (for every hour). If you enter any other number, the controller will flash an error code (see section 2.3).

The controller constantly fetches the time from the RTC. When it sees that the correct logging interval has been reached, it turns the Raspberry Pi on, tells all the loggers to take readings, collects the readings, and sends them to the Pi. The Pi also receives a special flag that tells it when all of the data has been sent. After it receives this flag, it takes a picture, then shuts down. Everything can then sleep until the next logging interval.

\paragraph{MAX\_PHOTODIODES}
The logger has a \textit{MAX\_PHOTODIODES} as well. It is used to limit the maximum size of the data structure that holds the photodiode readings. This data structure needs to be the same size for both the logger and controller, or data won't be received by the controller. Even if the logger is using less than eight photodiodes, this number still needs to be eight for both the logger and the controller. Don't worry if you are using less than eight photodiodes - the number you are actually using is defined by \textit{NUM\_PHOTODIODES}.

\subsection{Putting everything together}

\subsubsection{Connecting the RTC to the controller}
The controller has no way of knowing the time by itself. The Raspberry Pi can keep track of time to some extent, but it drifts very quickly when it's not attached to a proper time source that it can update itself with. Timekeeping will also stop every time we turn the Pi off, so it will very quickly become out of date.

To solve this problem, the controller uses a Real Time Clock chip called the DS1307. This ticks away on its own 3V battery most of the time, and can last years on one coin cell. This allows us to shut down the Pi, and still keep time. The controller just sends the time to the Pi before it sends any data, so that the Pi can store data with the right timestamp. We are using a breakout board from Adafruit which allows easy interfacing with the controller. \newline

\textbf{Note: The DS1307 needs 5V to wake it up from sleeping so that it can communicate with the controller. But the controller is a 3.3V device, and 5V would fry its I/O pins. When soldering the breakout board, leave out the two 2.2k resistors. This forces the board to communicate using 3.3V instead of 5V.} \newline

Once the board is soldered, it needs to be connected to the controller. This is straighforward. Connect the \textit{SDA} pin of the board to pin A4 of the Moteino, and connect the \textit{SCL} pin to pin A5 of the Moteino. Connect the \textit{GND} pin to to the Moteino's \textit{GND}, or to circuit ground. The \textit{5V} pin needs to be connected to the same power input as the Moteino and Raspberry Pi - this is the 5V output from the PowerBoost, outlined below.

For the full tutorial on soldering the RTC breakout, see \url{https://learn.adafruit.com/adding-a-real-time-clock-to-raspberry-pi/wiring-the-rtc}.

\subsubsection{Setting the time}
The DS1307 is not a precision clock. It can drift by up to  +/-2 seconds a day (or about a minute a month), which is worsened if the temperature is very variable. So at the very least, you'll need to set the time just before deploying it. Ideally you would reset it every few weeks (there is a more accurate clock, called the ChronoDot, available - see \url{https://www.adafruit.com/product/255}).

To set the clock, all you need to do is upload the \textit{field\_monitor/controller/testing/set\_time.ino} script onto the controller Moteino. It will automatically set the time to the time on your computer. If you press \textit{Ctrl+Shift+m}, a serial monitor will open and print the time. Remember to re-upload \textit{controller.ino} afterwards!

\subsubsection{Connecting the controller to the Raspberry Pi}

To enable the controller and the Pi to communicate, you need to connect the four jumper leads coming from the controller board as follows:

\begin{itemize}
 \item Find the yellow jumper lead coming from the controller board
 \item Locate the ``RX'' pin of the Pi. If you are looking at the Pi with the USB ports closest to you, this is the fifth pin down from the top of the right hand header
 \item Connect the yellow jumper to the ``RX'' pin of the Pi
 \item Find the orange jumper lead coming from the controller board
 \item Locate the ``TX'' pin of the Pi. If you are looking at the Pi with the USB ports closest to you, this is the fourth pin down from the top of the right hand header
 \item Connect the orange jumper to the ``TX'' pin of the Pi
 \item Find the red jumper lead coming from the controller board
 \item Find the ``5V'' pin of the Pi. If you are looking at the Pi with the USB ports closest to you, this is the first pin on the top of the right hand header
 \item Connect the red jumper to the ``5V'' pin of the Pi
 \item Find the grey jumper lead coming from the controller board
 \item Find the ``GND'' pin of the Pi. If you are looking at the Pi with the USB ports closest to you, this is the third pin down from the top of the right hand header
 \item Connect the grey jumper to the ``GND'' pin of the Pi
\end{itemize}

\subsubsection{Powering the base station}
The base station utilises a 3.7V Lithium Ion battery for power storage. This is topped up by two 6V solar panels wired in parallel. They are in parallel so that the amount of current they produce is doubled, but their output voltage is still 6V. You can add more solar panels to this array if the battery is failing to keep up with the power requirements of the project.

An Adafruit solar charger breakout (MCP73871) is used to control battery charging. This will maintain maximum current draw from the solar panels and will automatically stop charging when the battery is full. The solar charger is fairly straighforward: The solar panel output goes to \textit{DCIN}, the battery goes to \textit{BATT}, and the load (the Raspberry Pi/Moteino circuit) goes to \textit{B+} (Not \textit{L+} or \textit{LOAD}. This is so that it only sees the battery voltage, not the solar panel voltage. 6V would be too much for the PowerBoost). If you are soldering one of these from scratch, you will also need to solder in the capacitor.

As well as solar, you can recharge the LiPo with a normal 5V wall plug charger that can output at least 500mA. Unplug the solar panel DC jack and plug the charger into the mini USB port on the solar charger. The green LED will light up when the battery is charged. 

Because the battery is only 3.7V, it needs to be boosted up to 5V to power the Raspberry Pi and Moteino. The PowerBoost 500 does this. The output from the solar charger goes to \textit{Bat}, and the load is connected to \textit{5V}. In the current setup, two green screw terminals are used to connect the base station to \textit{5V} and the solar charger \textit{B+} output to \textit{Bat}. The negatives are marked with black.

There is a switch on the \textit{5V} output so that you can turn off the base station entirely if you need to. This is an optional addition if you are building from scratch, but it's useful.

Both the Moteino and the Pi are connected to the \textit{5V} output of the PowerBoost. However, to save power, the Moteino can turn off the Raspberry Pi. To achieve this, an N-channel MOSFET connects the Pi to ground only when its gate is activated by digital pin 4 of the Moteino. The Moteino can therefore turn the Pi on and off by setting pin 4 to \textit{OUTPUT}, then setting it \textit{HIGH} or \textit{LOW}.

There is information on the solar charger at \url{https://www.adafruit.com/product/390} and information on the PowerBoost 500 at \url{https://www.adafruit.com/product/1944}.

\subsubsection{Powering the logger}

The logger is powered by 4 x AA NiMH LSD (Low Self Discharge) batteries. There is a switch to enable the logger to be turned off.

The battery pack should last from one to six months depending on the logging frequency. You can add a 6V, 0.6W solar panel in parallel with the battery pack to charge the batteries (remember to use a diode so that current doesn't leak back into the solar panel during the night). This solar panel is small enough that it should trickle charge the batteries without overcharging them.

The batteries can be recharged in a standard NiMH (Nickel Metal Hydride) AA battery charger.

\subsection{Connecting the photodiodes}

The logger is part of a board which contains eight terminal blocks. Simply attached the positive and negative leads of the photodiodes to the right sides of the blocks (the negative side of the block has a black mark). All of the circuitry needed to read from the photodiodes is on the board - don't worry if you plug them in the wrong way around by accident, they will be fine. The board contains 5.6k resistors. Photodiodes generate current when they detect light. This current flows through the resistor, creating a voltage drop. The logger measures the voltage coming from the resistor. The 5.6k resistor was chosen because it will prevent the output voltage going above the logger's maximum input of 3.3V, even in very bright sunlight.

For the Hammamatsu G1115 photodiode, the positive leg can be identified as being the one closest to the little tab that sticks out horizontally from the bottom of the housing. There's also a black mark on that side if you look at the top of the photodiode.

\subsection{Placement}

The controller and loggers communicate best when their antennae are perpendicular to ground and as straight as possible. If they can't be straight (i.e. to fit inside an enclosure), the signal strength will be reduced. Also, the more material is between them, the weaker the signal (plants contain a lot of water, and water isn't good for radio signals). Anything that contains metal, such as vehicles, could easily block the signals. If you're frequently getting a low RSSI (see section 3.3), you might need to move your logger and controller closer together. Raising them off the ground or just out of the plant canopy will help.

As the base station is solar powered, make sure it's placed somewhere that will get good sunlight year round. You can always add another (6V, 2W) solar panel in parallel to produce more current. Remember to add a diode so that current can't leak back into the solar panel at night.

\section{RETRIEVING DATA}

At some point you will want to see the data that the Pi has been collecting. It's a good idea to do this at least once during setup, to check that everything is working properly (i.e. if you want to log every 15 minutes, check after 15 minutes that at least one set of data has been recorded). There are two ways to fetch the data from the Pi. Both involve some disruption of data logging. \newline

\textbf{If you accidentally delete the \textit{data} folder, your data will be lost - there's no Recycle Bin. The folder structure will be recreated by the script the next time it runs.}

\subsection{Copying from the SD card}
The Pi's filesystem is a Linux filesystem. This means that Windows computers won't be able to read it. But, you can use a Linux computer to copy the data directly from the SD card:

\begin{itemize}
 \item Wait until the Pi is off - when it's not logging, none of its LED's will be lit 
 \item Remove the red jumper wire from the Raspberry Pi - we don't want it turning on without an SD card
 \item Remove the micro SD card from the Pi. It's located on the opposite side to the USB/Ethernet ports. If you depress it once (gently) it will pop out
 \item Insert the micro SD card into an SD card adapter or micro SD to USB (like this one \url{https://www.amazon.co.uk/Memwah-Micro-SD-Card-Reader/dp/B004WFT762}
 \item Plug the adapter into your computer/laptop
 \item The SD card will be mounted like a normal USB stick or external drive. It will appear as two drives - pick the largest one
 \item Find the directory called \textit{/home/pi/data}
 \item Copy the directory to your computer
 \item Unmount/eject the card, and put it back in the Pi. Replace the red power wire
\end{itemize}

Note that this will \textbf{only} work with Linux. If you need to do this in Windows, you need to find a utility that can read \textit{ext4} formatted filesystems.

\subsection{Copying over wired connection}

The second method involves connecting to the Pi over SSH as described in section 2.1.1. If you haven't done this yet, you will need to follow the instructions for setting up a new connection within the same subnet as the Raspberry Pi. \textbf{This method will only work if the Pi can be powered seperately from the controller}. This is because the controller is set up to cut power to the Pi after a certain length of time. So, this method is best if you have retrieved the Pi and have it in the office, or if you can connect a portable power supply to the Pi (like a power pack for a mobile phone). A 5V, 2A power supply is best.

The good thing about this system is that if you can do it between logging intervals, you won't lose any data. You can also use this method to quickly check that the Pi is logging, without having to remove the SD card or copy any data.

\paragraph{If the system is still logging:}
Wait until it is off first - no LED's should be lit. Remove the red jumper wire coming from the controller. You can leave the other three wires connected. Now connect your laptop to the Pi with the Ethernet cable, and connect the seperate power to the Pi through the micro USB port.

\paragraph{If the system is not logging:}
Make sure that the controller board is switched off with the slide switch. Now connect the Ethernet cable between your computer and the Pi, and connect the seperate power supply to the Pi through the micro USB port. \newline

You can now log in to the Pi using SSH, and proceed to fetch the data: \newline

\textbf{For Linux:} \newline

Once you are logged in, you can fetch the data with the following command (\textit{data} is the directory we want to copy, and assuming you are using the IP address suggested in section 2.1.1):

\begin{verbatim}
 scp -rp data user@178.122.1.50:/place/to/put/data
\end{verbatim}

Once you have downloaded the data, you can turn the Pi off with:
\begin{verbatim}
 sudo halt
\end{verbatim}

\textbf{For Windows 7:} \newline

For Windows, you need to install a utility called WinSCP (\textbf{Note:} If you haven't installed Putty, WinSCP won't install. Install \textit{field\_monitor/windows\_utils/putty.exe} first). This will allow you to easily download files from the Pi:

\begin{itemize}
 \item In \textit{field\_monitor/windows\_utils}, there is a file called \textit{WinSCP-5.9-Setup.exe}. Copy this to your computer and double click to run it. It will install a program called \textit{WinSCP}
 \item Once it has installed, open WinSCP
 \item Click on \textit{New Site}
 \item The \textit{File protocol} should be \textit{STFP}
 \item In \textit{Host name} put \textit{178.122.1.200}
 \item The \textit{Port number} should be \textit{22}
 \item In \textit{User name} type \textit{pi} and in \textit{Password} type \textit{gogerddan}
 \item Click \textit{Login}
 \item If a warning pops up, click \textit{Yes}
 \item The Raspberry Pi's file structure will appear in the right hand pane. Your computer's file structure is in the left hand pane
 \item In the left hand pane, navigate to the directory on your computer that you want to download the data to (it defaults to \textit{My Documents}
 \item Select the \textit{data} folder in the right hand (Pi) pane so that it's highlighted
 \item Click \textit{Download} 
 \item In the popup box, click \textit{OK}
 \item The \textit{Data} folder will be downloaded to the location you selected
\end{itemize}

Once you have downloaded the data, you can turn off the Pi:

\begin{itemize}
 \item In WinSCP, go to \textit{Commands} - \textit{Open Terminal}
 \item In the \textit{Enter command} field, type \textit{sudo halt}
 \item Click \textit{Execute}
 \item The Pi will shut down
\end{itemize}

If the system is still logging, disconnect the Ethernet cable, remove the seperate micro USB power source and replace the red jumper wire. 

\subsection{Understanding the data}

In the \textit{/home/pi/data} directory, you will see another directory called \textit{images}, as well as two files, \textit{log.txt} and \textit{data.csv}. The \textit{images} directory contains all of the images captured by the Raspberry Pi. They are named with the timestamp of when they were taken, so you can easily identify their correct order. The \textit{log.txt} file is a log produced by the Python script. It will contain some basic information about any errors the script encountered; so take a look at this if there have been any problems with the logging. 

The third item, \textit{data.csv}, is a CSV file of all of the data from the loggers. The data is recorded in the following format: 

\begin{verbatim}
SENDER_ID NETWORK_ID LIGHT_1 LIGHT_2 LIGHT_3 LIGHT_4 LIGHT_5 LIGHT_6 LIGHT_7 LIGHT_8 RSSI
\end{verbatim}

The \textit{SENDER\_ID} identifies which logger the data is from - it's the ID you would have set in the code when you uploaded \textit{logger.txt} to the logger. The \textit{NETWORK\_ID} identifies which network the logger is on. This is followed by the eight light readings: The photodiodes are read from in order, from pin A0 to pin A7. So, the reading from the photodiode attached to pin A7 will be at \textit{LIGHT\_8}. 

The final value, \textit{RSSI} (Received Signal Strength Indicator), is a number that shows the strength of the signal from the logger. The higher the number the better the signal (it will always be negative - usually never higher than -25). If this number is really low, below -90, the logger might be struggling to send data back to the controller.

\subsection{Deleting data}

At some point you'll probably need to delete some of the data on the Raspberry Pi. This is easy to do with an Ethernet connection. To remove all of the data (don't worry, the Python script will recreate the \textit{data} directory next time it runs), you can type:

\begin{verbatim}
  rm -r data
\end{verbatim}

To remove just one file:

\begin{verbatim}
  rm file_name
\end{verbatim}

To navigate to the \textit{images} directory and delete all images:

\begin{verbatim}
  cd data/images
  rm *.jpg
\end{verbatim}

You can also use WinSCP to delete files and folders, if you're using Windows.

\end{document}