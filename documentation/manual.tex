\documentclass[10pt]{article}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{float}
\graphicspath{ {images/} }
\begin{document}

\begin{center}
\textbf{Setting up the Raspberry Pi based field sensor monitor}

August 2016
\end{center}
\newpage

\tableofcontents
\newpage

\section{INTRODUCTION}
This document describes how to set up and use the field monitoring system based on a Raspberry Pi base station and Moteino/Arduino based loggers. It provides a 
description of the hardware used and how to set up specific parameters in software, such as logging frequency.


In this document, the term ``controller'' refers to the Moteino which is attached to the Raspberry Pi. It receives data from ``loggers'', which are the independent
Moteinos with photodiodes attached. The Raspberry Pi takes pictures and is turned off and off by the controller. The term ``base station'' refers to the combination
of Raspberry Pi and Controller, because they work together.

The network operates on a star topology, with individual battery powered loggers reporting back to a base station. Loggers read from their photodiode arrays only when
they are told to by the controller. The controller tells the loggers when to read from their sensors, and also turns the Raspberry Pi on and off. Turning the Pi off when
it's not needed results in a dramatic power saving. Like the loggers, the controller is a Moteino microcontroller with a radio attached. It's necessary to set up radio
parameters so that the right loggers are talking to the right controller. These parameters are set out and explained in this document.

The Raspberry Pi acts as a data logger and camera operator. At each logging interval (which must be a multiple of 5 minutes) it is woken by the controller. The controller
sends any data received from the loggers to the Raspberry Pi. Once this data has been received, the Pi captures and saves an image before automatically shutting down.

\subsection{On Your Computer}

\subsubsection{Development Environment}
For uploading code to the controller and loggers, you can use the Arduino IDE (Integrated Development Environment). This is a cross platform IDE (you can download it for
Windows as well as Mac and Linux) which can be found at \url{https://www.arduino.cc/en/Main/Software}. There is a good overview of how to use the Arduino IDE at
\url{https://www.arduino.cc/en/Guide/Environment}. 

When you have Arduino installed, there are a couple of things you need to do before you can upload code. There are some extra bits of code, called libraries, that the
field logging system uses. You can download these, but they are included with the files for this project in \textit{field\_monitor/arduino\_libraries}. These need to
go in a specific place for the Arduino IDE to find them. For windows, you should have a directory called \textit{My Documents/Arduino/libraries}. Place all of the folders
inside \textit{field\_monitor/arduino\_libraries} into this directory. For Linux, they need to go in \textit{~/sketchbook/libraries}. 

You need to restart the Arduino IDE for it to find the libraries.

You also need to make sure you have the right board selected. The Moteino is very similar to the Arduino Uno, so we can use that as our upload target:

\begin{itemize}
 \item Open Arduino IDE 
 \item Go to Tools - Board
 \item Select ``Arduino Uno''
\end{itemize}

You also need to select the right port:

\begin{itemize}
 \item Open Arduino IDE 
 \item Go to Tools - Port
 \item Select the port that your Moteino is on. If you're not sure, unplug the Moteino, and see which one disappears
\end{itemize}

Once these are set up, you can use \textit{File - Open} to open the sketch you want to edit (in this case, \textit{field\_monitor/controller.ino} or \textit{field\_monitor/logger.ino}. The big tick at the top of the screen is used to \textbf{compile} to code; it should compile without errors. The arrow is used to upload the code to the target board.

When you upload to the Moteino, its onboard LED will flash a few times when uploading, then stop. If it carries on flashing, check out the error codes in section 2.2 to find out why.

\subsection{Additional hardware}
You will need an SD card reader and a computer that either has an SD card port or a USB adapter (Google ``usb sd card adapter'').

To connect the Moteino to your computer so that you can program it, you will need an FTDI cable like this one
\url{http://uk.rs-online.com/web/p/interface-development-kits/0429307/}. The cable \textbf{must} have 5V power and 3.3V logic. The Moteino is designed to run at 3.3V,
so 5V logic is too high (the power input can be 5V, because this goes through a regulator which lowers it to 3.3V). This connects to the 6-pin header on the Moteino. Make
sure that when you plug it in, the black wire (ground) on the cable connects to the \textit{GND} pin of the header. \newline

\textbf{Before plugging in the Moteino, it's a good idea to turn off power from any other sources. You'll probably get away with not doing this, but it's good practice.} \newline

\begin{itemize}
 \item Pick up the cable and the Moteino
 \item Have a look at the 6-pin header on the Moteino. You can see that at one end, a pin is labelled \textbf{GND}, and at the other, a pin is labelled \textbf{DTR}
 \item Line up the FTDI header so that the black wire is lined up with \textbf{GND}, and the green wire is lined up with \textbf{DTR}
 \item Plug it in! Depending on what code the Moteino is already running, the LED might blink
\end{itemize}

\section{SETUP}

\subsection{Raspberry Pi}
The SD card image provided has everything already set up, but there are some more details here if you need to change anything. If you just want to set up a new Pi with the
provided image, go to \textbf{Setting up the Pi: The Easy Way}.

The Raspberry Pi is set up so that it automatically runs a script when it starts. This script listens for any input from the controller and then captures and saves an image
using the camera. Then it shuts down the pi. This script is located in \textit{/home/pi/scripts} and it runs from \textit{/etc/rc.local}. Scripts run from \textit{rc.local}
run as the ``root'' user (similar to Administrators in Windows). You can look at this file by typing \textit{cat /etc/rc.local}. The Raspberry Pi is turned off and off
by the controller; it turns the Pi on, waits for it to complete its tasks, then turns it off.

\subsubsection{Setting up the Pi: The Easy Way}
All you need to set up a Raspberry Pi this way is the Pi itself, an SD card (preferably class 10, 8GB or greater) and card reader, and the camera module.

There is a file called \textit{pi\_logger.img} included in \textit{field\_monitor/raspberry\_pi}. This is an image file, and it's basically an ``image'' of a working Pi
running our code and with our settings. If we flash this image to a new SD card, it will have everything we need for the Pi to work with no setup. 

In Linux, use the \textit{dd} tool to flash the new SD card. The command is \textit{dd if=field\_monitor/raspberry\_pi/pi\_logger.iso of=/path/to/new/sdcard}. 

In Windows, follow the instruction from the Raspberry Pi Foundation at \url{https://www.raspberrypi.org/documentation/installation/installing-images/windows.md}. It's
not as hard as it looks! You just need to install a program called Win32DiskImager, which will allow you to write to the SD card.

If you use an SD card with a capacity greater than 8GB, you will still only have 8GB of storage unless you expand the partition so that the Pi can
access the extra room. To do this, you will need to access the Pi over Ethernet. The image file is already set up to allow you to do this, but you will need to
do some setting up on your own computer as well. If you're using Linux, there are instructions in section 2.1.2. If you are using Windows, here's what you need
to do (for Windows 7):

\begin{itemize}
 \item Download and install Putty from \url{http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html}
 \item 
\end{itemize}


Once you have the SD card flashed, install it in the Raspberry Pi, and connect the camera. There are instructions on how to connect the camera at
\url{https://www.raspberrypi.org/documentation/usage/camera/} (just the ``Connecting the Camera'' part - the rest is already set up on the SD card).

\subsubsection{Setting up the Pi: The Harder Way}
If you're familiar with Linux, the command line and SSH, you can set everything up from scratch. We will set up the Pi to connect via Ethernet to your machine, so you don't
even need an internet connection (this is also useful for downloading data from the Pi when it's in the field - see later section). This section assumes that you already
have a Pi running Raspbian (Jessie or later) which you want to set up for use with this system, and that you have root access. 

The first thing to do is to set up the Ethernet connection so that your machine can communicate directly to the Pi. If your Pi is already connected to the internet, this
isn't really necessary, but it does provide another avenue of data collection when the Pi is located remotely. To connect to the Pi this way, your machine and the Pi 
need to be within the same subnet. The easiest way to do this is to set up static IP adresses on the Pi and on your machine.

To set a static IP on the Pi , you need to mount the SD card in your machine and edit \textit{/etc/dhcpcd.conf}. Insert the following at the bottom of the file (you can 
replace the IP address with whatever you prefer):

\begin{verbatim}
interface eth0

static ip_address=192.168.1.10/24
static routers=192.168.1.1
static domain_name_servers=192.168.1.1
\end{verbatim}

Now, set up a new ethernet connection on your machine with an IP address within the same subnet. In Ubuntu, this is done as follows (assuming the Pi has the IP address
given above):

\begin{itemize}
 \item Click on the network icon in the menu bar
 \item Go to \textit{Edit Connections}
 \item Click on \textit{Add}
 \item Select the ``Ethernet'' option
 \item Give the connection a useful name, like ``Pi connect''
 \item Go to \textit{IPv4 settings}
 \item Change the \textit{Method} to ``Manual''
 \item Add an address - \textit{Address:} 192.168.1.100, \textit{Netmask:} 255.255.255.0, \textit{Gateway:} 192.168.1.1
\end{itemize}

You can of course alter these to suit your requirements.

Now you should be able to plug in an Ethernet cable between the Pi and your machine, and use SSH to access the Pi on the IP address you provided. In this case, that 
would be 192.168.1.10.

Once you are logged in, check that the camera is enabled. Type:

\begin{verbatim}
 sudo raspi-config
\end{verbatim}

Select the ``camera'' option. Select ``finish'' to set the option and reboot. It's also a good idea to change from the default password if you haven't already - 
use the \textit{passwd} command. 

Next, we need to set up the required Python packages. If you have an internet connection, you can just install these via \textit{apt-get} - the following applies if 
you only have a direct connection to the Pi, via SD card or Ethernet.

There are seven packages located in \textit{field\_monitor/raspberry\_pi/packages}. To get them onto the Pi, you can just mount the SD card
and copy them into a suitable directory to install from (such as ~), or you can copy them over the Ethernet connection using Secure Copy (SCP). To use SCP, the 
command is:

\begin{verbatim}
scp path/to/file/being/copied pi@192.168.1.10:/home/pi
\end{verbatim}

The packages need to be installed in the right order, as some depend on others. The command to install the \textit{.deb} packages is:

\begin{verbatim}
 sudo dpkg -i <package name>
\end{verbatim}

For the others, navigate into the package directory, e.g.:

\begin{verbatim}
 cd netifaces-0.10.4
\end{verbatim}

Then install using Python:

\begin{verbatim}
 sudo python setup.py install
\end{verbatim}

The installation order is:

\begin{itemize}
 \item libpython2.7-dev
 \item libpython-dev 
 \item python2.7-dev 
 \item python-dev 
 \item netifaces
 \item picamera
 \item piserial
\end{itemize}

Once all of the packages are installed, you need to upload a Python script to the Raspberry Pi. The script is located at
\textit{field\_monitor/raspberry\_pi/process\_data.py} and controls everything relevant to the Pi's field monitoring. As with the packages, you can upload this by
mounting the SD card or by using SCP. It's recommended to place it in a directory called \textit{/home/pi/scripts}. You also need to create a directory called
\textit{/home/pi/data} for the CSV files to be stored, and another called \textit{/home/pi/data/images} for the images captured by the camera. If you have a different
setup, change the \textit{data\_file\_name} and \textit{image\_file\_name} variables in \textit{process\_data.py} to the paths that you want to use.

The \textit{process\_data.py} script needs execute permissions, so make sure to run:

\begin{verbatim}
 chmod +x process_data.py
\end{verbatim}

We need the Python script to run at boot, so that when the controller turns on the Pi, the Pi automatically picks up data from the controller, captures an
image, and shuts itself down. We can do this by running \textit{process\_data.py} from \textit{/etc/rc.local}. Add the following line to \textit{/etc/rc.local} before
\textit{exit 0} (remember to change the file path, if it's not in \textit{/home/pi/scripts}):

\begin{verbatim}
 python /home/pi/scripts/process_data.py &
\end{verbatim}

Next there are a couple of things we need to do to allow the Pi to communicate with the controller over serial GPIO. First, edit \textit{/boot/cmdline.txt} and remove
the following:

\begin{verbatim}
 console=ttyAMA0,115200 kgdboc=ttyAMA0,115200
\end{verbatim}

This will prevent the Pi from sending data over serial when it's booting. Next, we need to disable the console on the serial port. While logged in to the Raspberry Pi,
type:

\begin{verbatim}
 sudo systemctl disable serial-getty@ttyAMA0.service
\end{verbatim}

Finally, even though we have disabled serial output at boot, there is still a line that prints when the kernel is being uncompressed. To get rid of this, we can 
get Raspbian to boot from an uncompressed image. This is a little tricky, and you can find the original instructions here 
\url{http://raspberrypi.stackexchange.com/questions/24583/ttyama0-disabled-but-still-shows-one-boot-message}. Otherwise, you can follow these instructions:

\begin{itemize}
 \item SSH into the Pi
 \item Type the following command (\textbf{Note:} If you're using an older Raspberry Pi (less than Model 2), replace \textit{kernel7} with \textit{kernel}):
	\begin{verbatim}
	 od -A d -t x1 /boot/kernel7.img | grep '1f 8b 08 00'
	\end{verbatim}
  \item You should see a line that looks like this (example 1):
	\begin{verbatim}
	 0017360 1f 8b 08 00 00 00 00 00 02 03 e4 fd 0b 7c 54 d5
	\end{verbatim}
	Or like this (example 2). Notice the extra \textbf{08} at the end:
	\begin{verbatim}
	 0017360 00 00 00 00 00 00 00 00 1f 8b 08 00 00 00 00 00
	\end{verbatim}
  \item If your output looks like example 1, the \textbf{offset} is 17360
  \item If your output looks like example 2, the \textbf{offset} is 17360 + 08, or 17368
  \item Type:
	\begin{verbatim}
	 sudo -i
	\end{verbatim}
	To get an interactive root shell
  \item Type the following command to create an uncompressed copy of the kernel, replacing the word \textit{OFFSET} with the \textbf{offset} number
	you found above:
	\begin{verbatim}
	 dd if=/boot/kernel.img skip=1 bs=OFFSET | gzip -d >/boot/kernel_uncompressed.img
	\end{verbatim}
  \item Now run the following commands to back up the current compressed kernel, and replace it with the uncompressed version:
	\begin{verbatim}
	 cd /boot
	 cp kernel.img kernel_compressed.img
	 cp kernel_uncompressed.img kernel.img
	 reboot
	\end{verbatim}
  \item If your Pi boots successfully, it has worked
\end{itemize}


That's it! Your Pi should now be able to run everything it needs for the field monitor.

\subsection{Logger}
The logger is the Moteino with the light sensor array attached. It runs from 2 x AA batteries and has a low power radio to send data back to the controller. The controller
that the logger is sending data back to must have the same \textit{NETWORK\_ID} as the logger, or they can't communicate.

When setting up a new logger, there are a few things that you need to change, and a few things that you can change if you want to. As a minimum, you need to:

\begin{itemize}
 \item Check that the logger is on the right network, so that it can communicate with the right controller
 \item Check that the logger has the right \textit{CONTROLLER\_ID} - this is the \textit{LOGGER\_ID} of the controller it's sending data back to
 \item Check that the logger's \textit{LOGGER\_ID} is unique on it's network
 \item Check that the logging frequency is correct
\end{itemize}

When you apply power to the logger, you shouldn't see any activity on the LED. If the LED flashes, you have problem. The logger automatically checks some of its parameters to make sure that they aren't outside the limits. You will see several flashes in quick succession, followed by a two second gap. The number of flashes you see indicates the problem:

\begin{itemize}
 \item \textbf{Two flashes}	- the number of photodiodes is too high (more than 8) or too low (less than 0)
 \item \textbf{Three flashes}	- the network ID is too high (more than 253) or too low (less than 0)
 \item \textbf{Four flashes}	- the logger ID is too high (more than 253) or too low (less than 2)
 \item \textbf{Five flashes}	- the maximum number of photodiodes has been changed, and does not equal 8
\end{itemize}
   
\subsubsection{Radio parameters}

\paragraph{LOGGER\_ID}
The \textit{LOGGER\_ID} is the unique number of the logger. All loggers with the same \textit{NETWORK\_ID} need to have different \textit{LOGGER\_ID}'s. This is partly so 
that when you look at the resulting data, you will know what logger it came from. It also allows the radios to identify each other, and to prevent clashes between 
loggers. 

The logger ID is transmitted to the controller along with the data from the logger. Because there is a limit to how much data can be transmitted at once, there is a limit
to how big the \textit{LOGGER\_ID} can be, because it is only allowed to take up one byte, or eight bits. The highest number you can represent with eight bits is 255. So,
including zero, we can have up to 256 unique \textit{LOGGER\_ID}'s on one network (networks work the same way). One of these numbers (the number 1) is actually taken by
the controller, and the number 255 is used as a ``broadcast'', meaning that all loggers on the network can see data transmitted to 255.

So, when you are setting up a new logger, set the logger ID to something greater than 1 and less than 255, and make sure that no other loggers with the same 
\textit{NETWORK\_ID} have the same \textit{LOGGER\_ID}. 

\paragraph{NETWORK\_ID}
The \textit{NETWORK\_ID} is used to identify which loggers are on the same network, i.e. which loggers can talk to each other. If you have a Raspberry Pi set up in one
field, with a controller with a \textit{NETWORK\_ID} of 100, all of the loggers that need to talk to that controller must also have a \textit{NETWORK\_ID} of 100. If you 
set up another base station in a different field nearby, you probably don't want the loggers in the first field to also be transmitting to that controller.

So, each controller has a unique \textit{NETWORK\_ID}. Like \textit{LOGGER\_ID}'s, \textit{NETWORK\_ID}'s are limited. So the \textit{NETWORK\_ID} needs to be between 1 and 254, and all loggers that send data to that controller have the same \textit{NETWORK\_ID} as it.

\paragraph{CONTROLLER\_ID}
The \textit{CONTROLLER\_ID} is used to identify the controller, which acts as a ``gateway'' to the Raspberry Pi. So, it's the \textit{LOGGER\_ID} of the controller. Make
sure that you put the right textit{CONTROLLER\_ID} for the controller that the logger is sending to.

\paragraph{FREQUENCY}
This is just the frequency of the radio chip - 433MHz is within the Industry, Scientific and Medical frequency band, which means it is a legal frequency for low power
radio communications. Don't change this unless you know what you are doing.

\paragraph{ENCRYPTKEY}
This is an encryption key - only loggers with the same key can undertsand each other's transmissions. For this reason, like the \textit{NETWORK\_ID}, all loggers that
talk to each other (including the controller) must have the same \textit{ENCRYPTKEY}. It \textbf{must} be 16 characters long. This encryption also means that no one
else can pick up packets being sent on your network.

\subsubsection{Logging parameters}

\paragraph{NUM\_PHOTODIODES}
This is the number of photodiodes attached to the logger. They will be read from in order, from analog pin 0 to \textit{NUM\_PHOTODIODES}-1. Moteinos only have eight analog pins (A0 to A7), so this number should never be greater than 8, but it can be less, for example, if you need to use an analog pin for a different sensor. If you don't use all of them for the photodiodes, then always pick the highest number analog pin for the other sensor. So, if you want to use a temperature sensor, put it on A7, and then change \textit{NUM\_PHOTODIODES} to 7.

\subsection{Controller}
The controller is the Moteino attached to the Raspberry Pi. Most of the parameters for the controller are the same as for the logger. The controller's \textit{LOGGER\_ID} is the logger's \textit{CONTROLLER\_ID}. 

Like the logger, the controller will flash to indicate any problems:

\begin{itemize}
 \item \textbf{Three flashes}	- the network ID is too high (more than 253) or too low (less than 0)
 \item \textbf{Three flashes}	- the logger ID is too high (more than 253) or too low (less than 2)
 \item \textbf{Four flashes}	- the maximum number of photodiodes has been changed, and does not equal 8
\end{itemize}

\subsubsection{Logging parameters}

\paragraph{READ\_FREQ}
This is the frequency at which readings should be taken. It can be any multiple of five minutes up to an hour. So, the options are: 0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55. The logger has no real concept of time - it just wakes up every five minutes to check for any radio packets sent by the controller. So, the logging frequency is only set on the controller.

The controller constantly fetches the time from the RTC. When it sees that the correct logging interval has been reached, it turns the Raspberry Pi on, tells all the loggers to take readings, collects the readings, and sends them to the Pi. The Pi also receives a special flag that tells it when all of the data has been sent. After it receives this flag, it takes a picture, then shuts down. Everything can then sleep until the next logging interval.

\paragraph{MAX\_PHOTODIODES}
The logger has a \textit{MAX\_PHOTODIODES} as well. It is used to limit the maximum size of the data structure that holds the photodiode readings. This data structure needs to be the same size for both the logger and controller, or data won't be received by the controller. Even if the logger is using less than eight photodiodes, this number still needs to be eight for both the logger and the controller. Don't worry if you are using less than eight photodiodes - the number you are actually using is defined by \textit{NUM\_PHOTODIODES}.

\subsection{Putting everything together}

\subsubsection{Connecting the RTC to the controller}
The controller has no way of knowing the time by itself. The Raspberry Pi can keep track of time to some extent, but it drifts very quickly when it's not attached to a proper time source that it can update itself with. Timekeeping will also stop every time we turn the Pi off, so it will very quickly become out of date.

To solve this problem, the controller uses a Real Time Clock chip called the DS1307. This ticks away on its own 3V battery most of the time, and can last years on one coin cell. This allows us to shut down the Pi, and still keep time. The controller just sends the time to the Pi before it sends any data, so that the Pi can store data with the right timestamp. We are using a breakout board from Adafruit which allows easy interfacing with the controller. \newline

\textbf{Note: The DS1307 needs 5V to wake it up from sleeping so that it can communicate with the controller. But the controller is a 3.3V device, and 5V would fry its I/O pins. When soldering the breakout board. leave out the two 2.2k resistors. This forces the board to communicate using 3.3V instead of 5V.} \newline

Once the board is soldered, it needs to be connected to the controller. This is straighforward. Connect the \textit{SDA} pin of the board to pin A4 of the Moteino, and connect the \textit{SCL} pin to pin A5 of the Moteino. Connect the \textit{GND} pin to to the Moteino's \textit{GND}, or to circuit ground. The \textit{5V} pin needs to be connected to the same power input as the Moteino and Raspberry Pi - this is the 5V output from the PowerBoost, outlined below.

For the full tutorial on soldering the RTC breakout, see \url{https://learn.adafruit.com/adding-a-real-time-clock-to-raspberry-pi/wiring-the-rtc}.

\subsubsection{Connecting the controller to the Raspberry Pi}

To enable the controller and the Pi to communicate, you need to connect the TX and RX pins of the Moteino to the TX and RX pins of the Pi as follows:

\begin{itemize}
 \item Find the pin on the Moteino labelled ``TX''
 \item Locate the ``RX'' pin of the Pi. If you are looking at the Pi with the USB ports closest to you, this is the fifth pin down from the top of the right hand header
 \item Connect the ``TX'' pin of the Moteino to the ``RX'' pin of the Pi
 \item Find the pin on the Moteino labelled ``RX''
 \item Locate the ``TX'' pin of the Pi. If you are looking at the Pi with the USB ports closest to you, this is the fourth pin down from the top of the right hand header
 \item Connect the ``RX'' pin of the Moteino to the ``TX'' pin of the Pi
\end{itemize}

\subsubsection{Powering the base station}
The base station utilises a 3.7V Lithium Ion battery for power storage. This is topped up by two 6V solar panels wired in parallel. They are in parallel so that the amount of current they produce is doubled, but their output voltage is still 6V. You can add more solar panels to this array if the battery is failing to keep up with the power requirements of the project.

An Adafruit solar charger breakout (MCP73871) is used to control battery charging. This will maintain maximum current draw from the solar panels and will automatically stop charging when the battery is full. The solar charger is fairly straighforward: The solar panel output goes to \textit{DCIN}, the battery goes to \textit{BATT}, and the load (the Raspberry Pi/Moteino circuit) goes to \textit{B+} (Not \textit{L+} or \textit{LOAD}. This is so that it only sees the battery voltage, not the solar panel voltage. 6V would be too much for the PowerBoost). If you are soldering one of these from scratch, you will also need to solder in the capacitor.

Because the battery is only 3.7V, it needs to be boosted up to 5V to power the Raspberry Pi and Moteino. The PowerBoost 500 does this. The output from the solar charger goes to \textit{Bat}, and the load is connected to \textit{5V}. There is a switch on the \textit{5V} output so that you can turn off the base station entirely if you need to. This is an optional addition if you are building from scratch, but it's useful.

Both the Moteino and the Pi are connected to the \textit{5V} output of the PowerBoost. However, to save power, the Moteino can turn off the Raspberry Pi. To achieve this, an N-channel MOSFET connects the Pi to ground only when its gate is activated by digital pin 4 of the Moteino. The Moteino can therefore turn the Pi on and off by setting pin 4 to \textit{OUTPUT}, then setting it \textit{HIGH} or \textit{LOW}.

There is information on the solar charger at \url{https://www.adafruit.com/product/390} and information on the PowerBoost 500 at \url{https://www.adafruit.com/product/1944}.

\subsubsection{Powering the logger}

The logger is powered by 4 x AA LSD (Low Self Discharge) batteries.


\end{document}